From: Radostan Riedel <raybuntu@googlemail.com>
Date: Mon, 9 Jul 2012 19:37:49 +0200
Subject: upstream fix for declaration errors in gcc4.7

---
 cctbx_sources/mmtbx/bulk_solvent/bulk_solvent.h |  416 +++++++++++------------
 1 file changed, 208 insertions(+), 208 deletions(-)

diff --git a/cctbx_sources/mmtbx/bulk_solvent/bulk_solvent.h b/cctbx_sources/mmtbx/bulk_solvent/bulk_solvent.h
index 6959f18..0be075f 100644
--- a/cctbx_sources/mmtbx/bulk_solvent/bulk_solvent.h
+++ b/cctbx_sources/mmtbx/bulk_solvent/bulk_solvent.h
@@ -322,6 +322,214 @@ private:
 };
 
 //------------------------------------------------------------------------------
+template <typename FloatType, typename ComplexType>
+FloatType
+scale(af::const_ref<FloatType> const& fo,
+      af::const_ref<ComplexType> const& fc)
+{
+    MMTBX_ASSERT(fo.size()==fc.size());
+    FloatType num=0.0;
+    FloatType denum=0.0;
+    for(std::size_t i=0; i < fo.size(); i++) {
+      FloatType fc_abs = std::abs(fc[i]);
+      num += fo[i] * fc_abs;
+      denum += fc_abs * fc_abs;
+    }
+    return (denum == 0 ? 0 : num/denum);
+};
+
+template <typename FloatType, typename ComplexType>
+FloatType
+scale(af::const_ref<FloatType> const& fo,
+      af::const_ref<ComplexType> const& fc,
+      af::const_ref<bool> const& selection)
+{
+    MMTBX_ASSERT(fo.size()==fc.size());
+    MMTBX_ASSERT(fo.size()==selection.size());
+    FloatType num=0.0;
+    FloatType denum=0.0;
+    for(std::size_t i=0; i < fo.size(); i++) {
+      if(selection[i]) {
+        FloatType fc_abs = std::abs(fc[i]);
+        num += fo[i] * fc_abs;
+        denum += fc_abs * fc_abs;
+      }
+    }
+    return (denum == 0 ? 0 : num/denum);
+};
+
+
+template <typename FloatType>
+FloatType
+scale(af::const_ref<FloatType> const& fo,
+      af::const_ref<FloatType> const& fc)
+{
+    MMTBX_ASSERT(fo.size()==fc.size());
+    FloatType num=0.0;
+    FloatType denum=0.0;
+    for(std::size_t i=0; i < fo.size(); i++) {
+      num += fo[i] * fc[i];
+      denum += fc[i] * fc[i];
+    }
+    return (denum == 0 ? 0 : num/denum);
+};
+
+template <typename FloatType, typename ComplexType>
+FloatType
+scale(
+  af::const_ref<FloatType> const& fo,
+  af::const_ref< std::complex<ComplexType> > const& fc1,
+  af::const_ref< std::complex<ComplexType> > const& fc2,
+  FloatType const& twin_fraction)
+{
+  MMTBX_ASSERT(fo.size()==fc1.size());
+  MMTBX_ASSERT(fo.size()==fc2.size());
+  af::shared<FloatType> fc_abs(fo.size());
+  for(std::size_t i=0; i < fo.size(); i++) {
+    FloatType fc_abs1 = std::abs(fc1[i]);
+    FloatType fc_abs2 = std::abs(fc2[i]);
+    fc_abs[i]=std::sqrt((1-twin_fraction)*fc_abs1*fc_abs1+
+                           twin_fraction *fc_abs2*fc_abs2);
+  }
+  return scale(fo,fc_abs.const_ref());
+};
+
+template <typename FloatType>
+FloatType
+r_factor(
+  af::const_ref<FloatType> const& fo,
+  af::const_ref<FloatType> const& fc,
+  FloatType const& scale)
+{
+  MMTBX_ASSERT(fo.size()==fc.size());
+  FloatType num=0.0;
+  FloatType denum=0.0;
+  for(std::size_t i=0; i < fo.size(); i++) {
+    num += std::abs(fo[i] - fc[i] * scale);
+    denum += fo[i];
+  }
+  if(denum == 0) return 1.e+9;
+  return num/denum;
+};
+
+template <typename FloatType>
+FloatType
+r_factor(
+  af::const_ref<FloatType> const& fo,
+  af::const_ref< std::complex<FloatType> > const& fc,
+  FloatType const& scale)
+{
+  MMTBX_ASSERT(fo.size()==fc.size());
+  FloatType num=0.0;
+  FloatType denum=0.0;
+  for(std::size_t i=0; i < fo.size(); i++) {
+    num += std::abs(fo[i] - std::abs(fc[i]) * scale);
+    denum += fo[i];
+  }
+  if(denum == 0) return 1.e+9;
+  return num/denum;
+};
+
+template <typename FloatType>
+FloatType
+r_factor(
+  af::const_ref<FloatType> const& fo,
+  af::const_ref< std::complex<FloatType> > const& fc,
+  af::const_ref<bool> const& selection,
+  FloatType const& scale)
+{
+  MMTBX_ASSERT(fo.size()==fc.size());
+  MMTBX_ASSERT(fo.size()==selection.size());
+  FloatType num=0.0;
+  FloatType denum=0.0;
+  for(std::size_t i=0; i < fo.size(); i++) {
+    if(selection[i]) {
+      num += std::abs(fo[i] - std::abs(fc[i]) * scale);
+      denum += fo[i];
+    }
+  }
+  if(denum == 0) return 1.e+9;
+  return num/denum;
+};
+
+template <typename FloatType>
+FloatType
+r_factor(
+  af::const_ref<FloatType> const& fo,
+  af::const_ref<FloatType> const& fc)
+{
+  MMTBX_ASSERT(fo.size()==fc.size());
+  FloatType sc = scale(fo,fc);
+  return r_factor(fo,fc,sc);
+};
+
+template <typename FloatType, typename ComplexType>
+FloatType
+r_factor(
+  af::const_ref<FloatType> const& fo,
+  af::const_ref<std::complex<ComplexType> > const& fc)
+{
+  MMTBX_ASSERT(fo.size()==fc.size());
+  FloatType sc = scale(fo,fc);
+  return r_factor(fo,fc,sc);
+};
+
+template <typename FloatType, typename ComplexType>
+FloatType
+r_factor(
+  af::const_ref<FloatType> const& fo,
+  af::const_ref<std::complex<ComplexType> > const& fc,
+  af::const_ref<bool> const& selection)
+{
+  MMTBX_ASSERT(fo.size()==fc.size());
+  MMTBX_ASSERT(fo.size()==selection.size());
+  FloatType sc = scale(fo,fc,selection);
+  return r_factor(fo,fc,selection,sc);
+};
+
+template <typename FloatType, typename ComplexType>
+FloatType
+r_factor(
+  af::const_ref<FloatType> const& fo,
+  af::const_ref< std::complex<ComplexType> > const& fc1,
+  af::const_ref< std::complex<ComplexType> > const& fc2,
+  FloatType const& twin_fraction)
+{
+  MMTBX_ASSERT(fo.size()==fc1.size());
+  MMTBX_ASSERT(fo.size()==fc2.size());
+  af::shared<FloatType> fc_abs(fo.size());
+  for(std::size_t i=0; i < fo.size(); i++) {
+    FloatType fc_abs1 = std::abs(fc1[i]);
+    FloatType fc_abs2 = std::abs(fc2[i]);
+    fc_abs[i]=std::sqrt((1-twin_fraction)*fc_abs1*fc_abs1+
+                           twin_fraction *fc_abs2*fc_abs2);
+  }
+  FloatType sc = scale(fo,fc_abs.const_ref());
+  return r_factor(fo,fc_abs.const_ref(),sc);
+};
+
+template <typename FloatType, typename ComplexType>
+FloatType
+r_factor(
+  af::const_ref<FloatType> const& fo,
+  af::const_ref< std::complex<ComplexType> > const& fc1,
+  af::const_ref< std::complex<ComplexType> > const& fc2,
+  FloatType const& twin_fraction,
+  FloatType const& scale)
+{
+  MMTBX_ASSERT(fo.size()==fc1.size());
+  MMTBX_ASSERT(fo.size()==fc2.size());
+  af::shared<FloatType> fc_abs(fo.size());
+  for(std::size_t i=0; i < fo.size(); i++) {
+    FloatType fc_abs1 = std::abs(fc1[i]);
+    FloatType fc_abs2 = std::abs(fc2[i]);
+    fc_abs[i]=std::sqrt((1-twin_fraction)*fc_abs1*fc_abs1+
+                           twin_fraction *fc_abs2*fc_abs2);
+  }
+  return r_factor(fo,fc_abs.const_ref(),scale);
+};
+
+//------------------------------------------------------------------------------
 // All scales (overall, overall anisotropic, etc) must be applied.
 template <
   typename FloatType=double,
@@ -744,214 +952,6 @@ template <typename FloatType>
  };
 
 //------------------------------------------------------------------------------
-template <typename FloatType, typename ComplexType>
-FloatType
-scale(af::const_ref<FloatType> const& fo,
-      af::const_ref<ComplexType> const& fc)
-{
-    MMTBX_ASSERT(fo.size()==fc.size());
-    FloatType num=0.0;
-    FloatType denum=0.0;
-    for(std::size_t i=0; i < fo.size(); i++) {
-      FloatType fc_abs = std::abs(fc[i]);
-      num += fo[i] * fc_abs;
-      denum += fc_abs * fc_abs;
-    }
-    return (denum == 0 ? 0 : num/denum);
-};
-
-template <typename FloatType, typename ComplexType>
-FloatType
-scale(af::const_ref<FloatType> const& fo,
-      af::const_ref<ComplexType> const& fc,
-      af::const_ref<bool> const& selection)
-{
-    MMTBX_ASSERT(fo.size()==fc.size());
-    MMTBX_ASSERT(fo.size()==selection.size());
-    FloatType num=0.0;
-    FloatType denum=0.0;
-    for(std::size_t i=0; i < fo.size(); i++) {
-      if(selection[i]) {
-        FloatType fc_abs = std::abs(fc[i]);
-        num += fo[i] * fc_abs;
-        denum += fc_abs * fc_abs;
-      }
-    }
-    return (denum == 0 ? 0 : num/denum);
-};
-
-
-template <typename FloatType>
-FloatType
-scale(af::const_ref<FloatType> const& fo,
-      af::const_ref<FloatType> const& fc)
-{
-    MMTBX_ASSERT(fo.size()==fc.size());
-    FloatType num=0.0;
-    FloatType denum=0.0;
-    for(std::size_t i=0; i < fo.size(); i++) {
-      num += fo[i] * fc[i];
-      denum += fc[i] * fc[i];
-    }
-    return (denum == 0 ? 0 : num/denum);
-};
-
-template <typename FloatType, typename ComplexType>
-FloatType
-scale(
-  af::const_ref<FloatType> const& fo,
-  af::const_ref< std::complex<ComplexType> > const& fc1,
-  af::const_ref< std::complex<ComplexType> > const& fc2,
-  FloatType const& twin_fraction)
-{
-  MMTBX_ASSERT(fo.size()==fc1.size());
-  MMTBX_ASSERT(fo.size()==fc2.size());
-  af::shared<FloatType> fc_abs(fo.size());
-  for(std::size_t i=0; i < fo.size(); i++) {
-    FloatType fc_abs1 = std::abs(fc1[i]);
-    FloatType fc_abs2 = std::abs(fc2[i]);
-    fc_abs[i]=std::sqrt((1-twin_fraction)*fc_abs1*fc_abs1+
-                           twin_fraction *fc_abs2*fc_abs2);
-  }
-  return scale(fo,fc_abs.const_ref());
-};
-
-template <typename FloatType>
-FloatType
-r_factor(
-  af::const_ref<FloatType> const& fo,
-  af::const_ref<FloatType> const& fc,
-  FloatType const& scale)
-{
-  MMTBX_ASSERT(fo.size()==fc.size());
-  FloatType num=0.0;
-  FloatType denum=0.0;
-  for(std::size_t i=0; i < fo.size(); i++) {
-    num += std::abs(fo[i] - fc[i] * scale);
-    denum += fo[i];
-  }
-  if(denum == 0) return 1.e+9;
-  return num/denum;
-};
-
-template <typename FloatType>
-FloatType
-r_factor(
-  af::const_ref<FloatType> const& fo,
-  af::const_ref< std::complex<FloatType> > const& fc,
-  FloatType const& scale)
-{
-  MMTBX_ASSERT(fo.size()==fc.size());
-  FloatType num=0.0;
-  FloatType denum=0.0;
-  for(std::size_t i=0; i < fo.size(); i++) {
-    num += std::abs(fo[i] - std::abs(fc[i]) * scale);
-    denum += fo[i];
-  }
-  if(denum == 0) return 1.e+9;
-  return num/denum;
-};
-
-template <typename FloatType>
-FloatType
-r_factor(
-  af::const_ref<FloatType> const& fo,
-  af::const_ref< std::complex<FloatType> > const& fc,
-  af::const_ref<bool> const& selection,
-  FloatType const& scale)
-{
-  MMTBX_ASSERT(fo.size()==fc.size());
-  MMTBX_ASSERT(fo.size()==selection.size());
-  FloatType num=0.0;
-  FloatType denum=0.0;
-  for(std::size_t i=0; i < fo.size(); i++) {
-    if(selection[i]) {
-      num += std::abs(fo[i] - std::abs(fc[i]) * scale);
-      denum += fo[i];
-    }
-  }
-  if(denum == 0) return 1.e+9;
-  return num/denum;
-};
-
-template <typename FloatType>
-FloatType
-r_factor(
-  af::const_ref<FloatType> const& fo,
-  af::const_ref<FloatType> const& fc)
-{
-  MMTBX_ASSERT(fo.size()==fc.size());
-  FloatType sc = scale(fo,fc);
-  return r_factor(fo,fc,sc);
-};
-
-template <typename FloatType, typename ComplexType>
-FloatType
-r_factor(
-  af::const_ref<FloatType> const& fo,
-  af::const_ref<std::complex<ComplexType> > const& fc)
-{
-  MMTBX_ASSERT(fo.size()==fc.size());
-  FloatType sc = scale(fo,fc);
-  return r_factor(fo,fc,sc);
-};
-
-template <typename FloatType, typename ComplexType>
-FloatType
-r_factor(
-  af::const_ref<FloatType> const& fo,
-  af::const_ref<std::complex<ComplexType> > const& fc,
-  af::const_ref<bool> const& selection)
-{
-  MMTBX_ASSERT(fo.size()==fc.size());
-  MMTBX_ASSERT(fo.size()==selection.size());
-  FloatType sc = scale(fo,fc,selection);
-  return r_factor(fo,fc,selection,sc);
-};
-
-template <typename FloatType, typename ComplexType>
-FloatType
-r_factor(
-  af::const_ref<FloatType> const& fo,
-  af::const_ref< std::complex<ComplexType> > const& fc1,
-  af::const_ref< std::complex<ComplexType> > const& fc2,
-  FloatType const& twin_fraction)
-{
-  MMTBX_ASSERT(fo.size()==fc1.size());
-  MMTBX_ASSERT(fo.size()==fc2.size());
-  af::shared<FloatType> fc_abs(fo.size());
-  for(std::size_t i=0; i < fo.size(); i++) {
-    FloatType fc_abs1 = std::abs(fc1[i]);
-    FloatType fc_abs2 = std::abs(fc2[i]);
-    fc_abs[i]=std::sqrt((1-twin_fraction)*fc_abs1*fc_abs1+
-                           twin_fraction *fc_abs2*fc_abs2);
-  }
-  FloatType sc = scale(fo,fc_abs.const_ref());
-  return r_factor(fo,fc_abs.const_ref(),sc);
-};
-
-template <typename FloatType, typename ComplexType>
-FloatType
-r_factor(
-  af::const_ref<FloatType> const& fo,
-  af::const_ref< std::complex<ComplexType> > const& fc1,
-  af::const_ref< std::complex<ComplexType> > const& fc2,
-  FloatType const& twin_fraction,
-  FloatType const& scale)
-{
-  MMTBX_ASSERT(fo.size()==fc1.size());
-  MMTBX_ASSERT(fo.size()==fc2.size());
-  af::shared<FloatType> fc_abs(fo.size());
-  for(std::size_t i=0; i < fo.size(); i++) {
-    FloatType fc_abs1 = std::abs(fc1[i]);
-    FloatType fc_abs2 = std::abs(fc2[i]);
-    fc_abs[i]=std::sqrt((1-twin_fraction)*fc_abs1*fc_abs1+
-                           twin_fraction *fc_abs2*fc_abs2);
-  }
-  return r_factor(fo,fc_abs.const_ref(),scale);
-};
-
-//------------------------------------------------------------------------------
 
 template <typename DataType, typename TagType>
 void
